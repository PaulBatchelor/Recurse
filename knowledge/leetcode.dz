ns leetcode
gr things related to the leetcode and leetcode strategy

nn grokking_notes
ln Grokking Notes
hl https://gist.github.com/tykurtz/3548a31f673588c05c89f9ca42067bc4

nn grind75
ln grind75: a collection of leetcode problems that you can
ln customize
hl https://www.techinterviewhandbook.org/grind75/

nn blind75
ln blind75: a curated collection of leetcod problems
hl https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions

nn leetcode75
ln leetcode75: a curated study guide of 75 leetcode problems
hl https://leetcode.com/studyplan/leetcode-75/

nn problems/322_coin_change
ln 322: Coin Change
hl https://leetcode.com/problems/coin-change
co references/optimization_problem $
cr can be modeled as an optimization problem
cr using the "standard form"
co $ paradigms/dynamic_programming
co $ grind75

nn references/optimization_problem
hl https://en.wikipedia.org/wiki/Optimization_problem
ln Optimization Problem (Computer Science): the problem
ln of finding the best solution from all feasible solutions.
ff What is an optimization problem?
fb the problem of finding the best solution from all feasible
fb solutions.

nn references/candidate_solution
ln Candidate solution: member of the set of possible solutions
ln in the feasible region of given problems.
co $ references/optimization_problem
cr the "best solution" is a candidate solution
ff What is a candidate solution?
fb A candidate solution is a solution in the feasible region
fb of given problems.

nn references/optimal_substructure
ln Optimal Substructure: in computer sience, a problem is
ln said to have optimal substructure if an optimal solution
ln can be constructed from optimal solutions of its
ln subproblems.
hl https://en.wikipedia.org/wiki/Optimal_substructure
co $ problems/322_coin_change
cr the coin change problem has an optimal substructure property
co $ paradigms/dynamic_programming
cr optimal substructure key piece in solving dynamic programming problems
ff What is optimal substructure?
fb Optimal substructure is a property of a problem where
fb an optimal solution can be constructed from optimal
fb solutions of its subproblems.

nn paradigms/dynamic_programming
ln Dynamic Programming

nn references/recurrence_relation
hl https://en.wikipedia.org/wiki/Recurrence_relation
ln Recurrence Relation: In mathematics, a recurrence
ln relation is an equation according to which the n 
ln nth term of a sequence of numbers is equal 
ln to some combination of the previous terms.
co $ references/optimal_substructure
cr used to represent optimal substructure
co $ problems/322_coin_change
cr Editorial: "the following recurrence relation holds"

nn python/lru_cache
hl https://docs.python.org/3/library/functools.html#functools.lru_cache
ln lru_cache(): Decorator to wrap a function with a
ln memoizing callable that saves up to the maxsize most recent calls. 
co $ problems/322_coin_change
cr used in top-down dynamic programming solution to avoid TLE

nn references/bottom_up_top_down
hl https://en.wikipedia.org/wiki/Bottom%E2%80%93up_and_top%E2%80%93down_design
ln Bottom-up and Top-down design: are both strategies of 
ln information processing and ordering knowledge, used in a 
ln variety of fields including software, humanistic and 
ln scientific theories (see systemics), and management and 
ln organization. In practice they can be seen as a style of 
ln thinking, teaching, or leadership. 
co $ paradigms/dynamic_programming
cr Dynamic programming can come in top-down or bottoms-up approaches
co $ problems/322_coin_change
cr DP solutions for top-down and bottoms-up

nn references/dynamic_programming
hl https://en.wikipedia.org/wiki/Dynamic_programming
ln Dynamic Programming: A mathematicl optimization method
ln and an algorithmic paradigm.
co $ paradigms/dynamic_programming

nn references/algorithmic_paradigm
hl https://en.wikipedia.org/wiki/Algorithmic_paradigm
ln Algorithmic Paradigm: An algorithmic paradigm is a
ln generic model or framework which underlies the design
ln of a class of algorithms.
co $ paradigms/algorithmic_paradigm

nn paradigms/algorithmic_paradigm
ln Algorithmic Paradigms

nn problems/238_product_of_array_except_self
ln 238: Product of array except self
hl https://leetcode.com/problems/product-of-array-except-self
co $ grind75

nn references/prefix_sum
hl https://en.wikipedia.org/wiki/Prefix_sum
ln Prefix Sum
co $ problems/238_product_of_array_except_self
cr Left/right product sum solution reminds me of prefix sum tables

nn problems/155_min_stack
hl https://leetcode.com/problems/min-stack
ln 155: Min Stack
co $ grind75

nn problems/89_validate_binary_search_tree
hl https://leetcode.com/problems/validate-binary-search-tree
ln 89: Validate Binary Search Tree
co $ grind75

nn references/binary_search_tree
hl https://en.wikipedia.org/wiki/Binary_search_tree
ln Binary Search Tree
co $ data_structures/binary_search_tree

nn data_structures/binary_search_tree
ln Binary Search Tree
co $ problems/89_validate_binary_search_tree

nn references/tree_traversal
hl https://en.wikipedia.org/wiki/Tree_traversal
ln tree traversal

nn references/tree_traversal/in_order
ln in-order tree traversal
co $ problems/89_validate_binary_search_tree
cr one solution for validating BST is using in-order traversal
co $ data_structures/binary_search_tree
cr in-order tree traversal on BST retrieves keys in ascending
cr order. I'd be most likely to try to implement a solution
cr this way in an interview setting because this property
cr is pretty well established for BSTs

nn problems/200_number_of_islands
ln LC 200: number of islands
co $ grind75
hl https://leetcode.com/problems/number-of-islands

nn references/depth_first_search
hl https://en.wikipedia.org/wiki/Depth-first_search
ln Depth-First-Search (DFS)
co $ paradigms/depth_first_search

nn paradigms/depth_first_search
ln Depth-First Search
co problems/200_number_of_islands $

nn references/disjoint_data_set
hl https://en.wikipedia.org/wiki/Disjoint-set_data_structure
ln Disjoint Data Set: a data structure that stores a
ln collection of disjoint (non-overlapping) sets.
co $ problems/200_number_of_islands
cr One of the esoteric solutions involves using a union find
cr disjoint data set

nn references/breadth_first_search
hl https://en.wikipedia.org/wiki/Breadth-first_search
ln Bread-first search (BFS)
co $ paradigms/breadth_first_search

nn paradigms/breadth_first_search
ln Breadth-First Search
co $ problems/200_number_of_islands

nn problems/994_rotting_oranges
hl https://leetcode.com/problems/rotting-oranges/description/
ln 994: number of islands
co $ paradigms/breadth_first_search
