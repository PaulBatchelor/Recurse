ns leetcode
gr things related to the leetcode and leetcode strategy

nn grokking_notes
ln Grokking Notes
hl https://gist.github.com/tykurtz/3548a31f673588c05c89f9ca42067bc4

nn grind75
ln grind75: a collection of leetcode problems that you can
ln customize
hl https://www.techinterviewhandbook.org/grind75/

nn blind75
ln blind75: a curated collection of leetcod problems
hl https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions

nn leetcode75
ln leetcode75: a curated study guide of 75 leetcode problems
hl https://leetcode.com/studyplan/leetcode-75/

nn problems/322_coin_change
ln 322: Coin Change
hl https://leetcode.com/problems/coin-change
co references/optimization_problem $
cr can be modeled as an optimization problem
cr using the "standard form"
co $ paradigms/dynamic_programming
co $ grind75

nn references/optimization_problem
hl https://en.wikipedia.org/wiki/Optimization_problem
ln Optimization Problem (Computer Science): the problem
ln of finding the best solution from all feasible solutions.
ff What is an optimization problem?
fb the problem of finding the best solution from all feasible
fb solutions.

nn references/candidate_solution
ln Candidate solution: member of the set of possible solutions
ln in the feasible region of given problems.
co $ references/optimization_problem
cr the "best solution" is a candidate solution
ff What is a candidate solution?
fb A candidate solution is a solution in the feasible region
fb of given problems.

nn references/optimal_substructure
ln Optimal Substructure: in computer sience, a problem is
ln said to have optimal substructure if an optimal solution
ln can be constructed from optimal solutions of its
ln subproblems.
hl https://en.wikipedia.org/wiki/Optimal_substructure
co $ problems/322_coin_change
cr the coin change problem has an optimal substructure property
co $ paradigms/dynamic_programming
cr optimal substructure key piece in solving dynamic programming problems
ff What is optimal substructure?
fb Optimal substructure is a property of a problem where
fb an optimal solution can be constructed from optimal
fb solutions of its subproblems.

nn paradigms/dynamic_programming
ln Dynamic Programming

nn references/recurrence_relation
hl https://en.wikipedia.org/wiki/Recurrence_relation
ln Recurrence Relation: In mathematics, a recurrence
ln relation is an equation according to which the n 
ln nth term of a sequence of numbers is equal 
ln to some combination of the previous terms.
co $ references/optimal_substructure
cr used to represent optimal substructure
co $ problems/322_coin_change
cr Editorial: "the following recurrence relation holds"

nn python/lru_cache
hl https://docs.python.org/3/library/functools.html#functools.lru_cache
ln lru_cache(): Decorator to wrap a function with a
ln memoizing callable that saves up to the maxsize most recent calls. 
co $ problems/322_coin_change
cr used in top-down dynamic programming solution to avoid TLE

nn references/bottom_up_top_down
hl https://en.wikipedia.org/wiki/Bottom%E2%80%93up_and_top%E2%80%93down_design
ln Bottom-up and Top-down design: are both strategies of 
ln information processing and ordering knowledge, used in a 
ln variety of fields including software, humanistic and 
ln scientific theories (see systemics), and management and 
ln organization. In practice they can be seen as a style of 
ln thinking, teaching, or leadership. 
co $ paradigms/dynamic_programming
cr Dynamic programming can come in top-down or bottoms-up approaches
co $ problems/322_coin_change
cr DP solutions for top-down and bottoms-up

nn references/dynamic_programming
hl https://en.wikipedia.org/wiki/Dynamic_programming
ln Dynamic Programming: A mathematicl optimization method
ln and an algorithmic paradigm.
co $ paradigms/dynamic_programming

nn references/algorithmic_paradigm
hl https://en.wikipedia.org/wiki/Algorithmic_paradigm
ln Algorithmic Paradigm: An algorithmic paradigm is a
ln generic model or framework which underlies the design
ln of a class of algorithms.
co $ paradigms/algorithmic_paradigm

nn paradigms/algorithmic_paradigm
ln Algorithmic Paradigms

nn problems/238_product_of_array_except_self
ln 238: Product of array except self
hl https://leetcode.com/problems/product-of-array-except-self
co $ grind75

nn references/prefix_sum
hl https://en.wikipedia.org/wiki/Prefix_sum
ln Prefix Sum
co $ problems/238_product_of_array_except_self
cr Left/right product sum solution reminds me of prefix sum tables

nn problems/155_min_stack
hl https://leetcode.com/problems/min-stack
ln 155: Min Stack
co $ grind75

nn problems/89_validate_binary_search_tree
hl https://leetcode.com/problems/validate-binary-search-tree
ln 89: Validate Binary Search Tree
co $ grind75

nn references/binary_search_tree
hl https://en.wikipedia.org/wiki/Binary_search_tree
ln Binary Search Tree
co $ data_structures/binary_search_tree

nn data_structures/binary_search_tree
ln Binary Search Tree
co $ problems/89_validate_binary_search_tree

nn references/tree_traversal
hl https://en.wikipedia.org/wiki/Tree_traversal
ln tree traversal

nn references/tree_traversal/in_order
ln in-order tree traversal
co $ problems/89_validate_binary_search_tree
cr one solution for validating BST is using in-order traversal
co $ data_structures/binary_search_tree
cr in-order tree traversal on BST retrieves keys in ascending
cr order. I'd be most likely to try to implement a solution
cr this way in an interview setting because this property
cr is pretty well established for BSTs

nn problems/200_number_of_islands
ln LC 200: number of islands
co $ grind75
hl https://leetcode.com/problems/number-of-islands

nn references/depth_first_search
hl https://en.wikipedia.org/wiki/Depth-first_search
ln Depth-First-Search (DFS)
co $ paradigms/depth_first_search

nn paradigms/depth_first_search
ln Depth-First Search
co problems/200_number_of_islands $

nn references/disjoint_data_set
hl https://en.wikipedia.org/wiki/Disjoint-set_data_structure
ln Disjoint Data Set: a data structure that stores a
ln collection of disjoint (non-overlapping) sets.
co $ problems/200_number_of_islands
cr One of the esoteric solutions involves using a union find
cr disjoint data set

nn references/breadth_first_search
hl https://en.wikipedia.org/wiki/Breadth-first_search
ln Bread-first search (BFS)
co $ paradigms/breadth_first_search

nn paradigms/breadth_first_search
ln Breadth-First Search
co $ problems/200_number_of_islands

nn problems/994_rotting_oranges
hl https://leetcode.com/problems/rotting-oranges/description/
ln 994: number of islands
co $ paradigms/breadth_first_search

nn problems/33_search_in_rotated_sorted_array
hl https://leetcode.com/problems/search-in-rotated-sorted-array
ln 33: search in rotated sorted array
co $ grind75

nn references/binary_search
hl https://en.wikipedia.org/wiki/Binary_search
ln Binary Search: algorithm that finds the position of
ln a target value in a sorted array.
co $ paradigms/binary_search

nn paradigms/binary_search
ln Binary Search
co $ problems/33_search_in_rotated_sorted_array

nn references/binary_search_java
hl https://algs4.cs.princeton.edu/11model/BinarySearch.java.html
ln Binary Search code snippet in Java, with with code comments
co $ paradigms/binary_search
rm Recommended by EV

nn references/sorted_array
hl https://en.wikipedia.org/wiki/Sorted_array
ln Sorted Array: an array data structure where each element
ln is sorted in numerical, alphabetical, or some other order.
co $ references/binary_search
cr sorted array is the data structure used in binary search

nn references/opionated_guide_binary_search
hl https://leetcode.com/discuss/study-guide/2371234/An-opinionated-guide-to-binary-search-
ln An opinionated guide to binary search
co $ paradigms/binary_search

nn paradigms/backtracking
ln Backtracking

nn references/backtracking
ln Backtracking
hl https://en.wikipedia.org/wiki/Backtracking
co $ paradigms/backtracking

nn problems/39_combination_sum
hl https://leetcode.com/problems/combination-sum/
ln 39: Combination sum
co $ grind75
co $ paradigms/backtracking

nn references/knapsack_problem
hl https://en.wikipedia.org/wiki/Knapsack_problem
ln Knapsack problem: given a set of items, each with a 
ln weight and a value, determine which items to include in 
ln the collection so that the total weight is less than or 
ln equal to a given limit and the total value is as large 
ln as possible.
co $ problems/39_combination_sum
cr this problem initially reminded me of a knapsack problem,
cr except that this problem enumerating all possibilities
cr instead of finding an optimal one
ff What is the knapsack problem?
fb The knapsack problem can be described as: given a set
fb of items, each with a weight and a value, determine
fb which items to include in the collection so that the
fb total weight is less than or equal to a given limit and
fb the total value is as large as possible.

nn references/combinatorial_optimization
hl https://en.wikipedia.org/wiki/Combinatorial_optimization
ln Combinatorial optimization is a subfield of mathematical 
ln optimization that consists of finding an optimal object 
ln from a finite set of objects,[1] where the set of 
ln feasible solutions is discrete or can be reduced to a 
ln discrete set.
co references/knapsack_problem $
cr knapsack problem is a problem in combinatorial optimization

nn paradigms/binary_search/upper_bound
ln Upper bound binary search problems
rm EV: upper bound problems are rarer but are part of
rm "find a range" problems

nn paradigms/binary_search/lower_bound
ln Lower bound binary search problems

nn references/binary_search_leetcode
hl https://leetcode.com/explore/learn/card/binary-search/
ln Binary Search Leetcode explore card
co $ paradigms/binary_search

nn problems/34_first_last_sorted_array
hl https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
ln 34: Find first and last element in sorted array
rm "find a range" problem
co $ paradigms/binary_search/upper_bound
co $ paradigms/binary_search
td work on LC 34: first/last element in sorted array

nn problems/278_first_bad_version
hl https://leetcode.com/problems/first-bad-version
ln 278: First Bad Version
co $ paradigms/binary_search/lower_bound
zz TODO: can we treat this as implicit?
co $ paradigms/binary_search

nn problems/875_koko_eating_bananas
ln 875: Koko eating bananas
hl https://leetcode.com/problems/koko-eating-bananas
co $ paradigms/binary_search/lower_bound
co $ paradigms/binary_search
co $ leetcode75

nn problems/1011_capacity_ship_packages_d_days
ln 1011: Capacity to ship packages within D days
hl https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
co $ paradigms/binary_search/lower_bound

nn problems/1_two_sum
hl https://leetcode.com/problems/two-sum/
ln 1: two-sum
co $ data_structures/hash_table
co $ grind75

nn data_structures/hash_table
ln Hash Table

nn references/hash_table
hl https://en.wikipedia.org/wiki/Hash_table
ln A hash table is a data structure that implements an
ln associative array, also called a dictionary or map.
co $ data_structures/hash_table

nn references/associative_array
hl https://en.wikipedia.org/wiki/Associative_array
ln associative array: an abstract data type that stores a
ln collection of key-value pairs, such that each possible
ln key appears at most once in the collection.
co references/hash_table $
cr a hash table implements an associative array

nn references/abstract_data_type
hl https://en.wikipedia.org/wiki/Abstract_data_type
ln abstract data type: mathematical model for data types,
ln defined by its behavior (semantics) from the point of
ln view of a user of the data, specifically in terms of
ln possible values, possible operations on the data of
ln this type, and the behavior of these operations.

nn problems/20_valid_parentheses
ln 20: Valid Parentheses
hl https://leetcode.com/problems/valid-parentheses/
co $ grind75
co $ data_structures/stack

nn data_structures/stack
ln Stack

nn references/stack
hl https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
ln Stack (abstract data type)
co $ references/abstract_data_type

nn problems/21_merge_two_sorted_lists
hl https://leetcode.com/problems/merge-two-sorted-lists/
ln 21: Merge two sorted lists
co $ data_structures/linked_list
co $ grind75

nn data_structures/linked_list
ln linked list

nn references/linked_list
hl https://en.wikipedia.org/wiki/Linked_list
ln linked list
co $ data_structures/linked_list

nn problems/121_best_time_to_sell_and_buy_stock
ln 121: Best Time to Sell and Buy Stock
co $ paradigms/greedy
cr I'm pretty sure this is a greedy algorithm? ("locally optimal choices")
co $ grind75

nn paradigms/greedy
ln Greedy

nn references/maximum_subarray_problem
hl https://en.wikipedia.org/wiki/Maximum_subarray_problem
ln Maximum Subarray problem
co $ problems/121_best_time_to_sell_and_buy_stock
cr reminds me of this problem

nn references/kadanes
hl https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm
ln Kadane's algorithm
co $ references/maximum_subarray_problem
cr used to solve maximum subarray problem
co $ problems/121_best_time_to_sell_and_buy_stock
cr I thought of Kadane's while working through this, though
cr I'm not sure how related they are

nn references/greedy_algorithm
hl https://en.wikipedia.org/wiki/Greedy_algorithm
ln Greedy Algorithm
co $ paradigms/greedy

nn problems/125_valid_palindrome
ln 125: valid palindrome
hl https://leetcode.com/problems/valid-palindrome
co $ grind75
co $ paradigms/two_pointer

nn paradigms/two_pointer
ln Two Pointer

nn references/two_pointer_technique
hl https://leetcode.com/articles/two-pointer-technique/
ln Two-Pointer Technique (leetcode)

nn problems/242_valid_anagram
hl https://leetcode.com/problems/valid-anagram
ln 242: valid anagram
co $ grind75
co $ data_structures/hash_table

nn problems/704_binary_search
hl https://leetcode.com/problems/binary-search/
ln 704: binary search
co $ grind75
co $ paradigms/binary_search

nn problems/235_lowest_common_ancestor_BST
ln 235: Lowest Common Ancestor (LCA) of a Binary Search Tree
co $ grind75
co $ data_structures/binary_search_tree

nn references/lowest_common_ancestor
hl https://en.wikipedia.org/wiki/Lowest_common_ancestor
ln Lowest Common Ancestor: the LCA of two nodes v and w
ln in a tree or DAG is the lowest node that has both v and
ln w as descendants, where we define each node to be
ln a descendant of itself
co $ problems/235_lowest_common_ancestor_BST

nn problems/2034_stock_price_fluctuation
hl https://leetcode.com/problems/stock-price-fluctuation
ln 2034: Stock Price Fluctuation
td Work on LC 2034: Stock Price Fluctuation

nn problems/635_design_log_storage_system
ln 635: Design Log Storage System
hl https://leetcode.com/problems/design-log-storage-system
td Work on LC 635: Design Log Storage System

nn problems/110_balanced_binary_tree
ln 110: balanced binary tree
hl https://leetcode.com/problems/balanced-binary-tree
co $ grind75
co $ data_structures/binary_tree

nn data_structures/binary_tree
ln binary tree

nn references/binary_tree
hl https://en.wikipedia.org/wiki/Binary_tree
ln Binary Tree: tree data structure in which a node has at most
ln two children: a left child and a right child.
co $ data_structures/binary_tree

nn problems/141_linked_list_cycle
hl https://leetcode.com/problems/linked-list-cycle/
ln 141: Linked List Cycle
co $ grind75
co $ data_structures/linked_list

nn references/floyds_algorithm
ln Floyd's Cycle Finding Algorithm
hl https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare
co $ data_structures/linked_list
co problems/141_linked_list_cycle $
cr Elegant solution with O(n) time and O(1) space
ff Describe Floyd's algorithm
fb Floyd's algorithm can be used for cycle detection in
fb linked lists (think tortois and hare). You a slow pointer
fb a fast pointer. If there's a cycle, the fast pointer will
fb eventually lap the fast pointer.

nn problems/287_find_the_duplicate_number
hl https://leetcode.com/problems/find-the-duplicate-number/
ln 287: Find the duplicate number
co $ grind75
co $ references/floyds_algorithm
cr one solution this problem uses a variant on floyd's algorithm

nn problems/232_implement_queue_using_stacks
hl https://leetcode.com/problems/implement-queue-using-stacks
ln Implement Queue using stacks
co $ data_structures/stack
co $ data_structures/queue

nn data_structures/queue
ln Queues

nn references/queues
hl https://en.wikipedia.org/wiki/Queue_(abstract_data_type)
ln Queue (Abstract Data Type)
co $ data_structures/queue

nn problems/169_majority_element
ln 169: Majority Element
hl https://leetcode.com/problems/majority-element
co $ grind75
co $ data_structures/hash_table
cr hash table was most straight forward
rm lots of weird solutions for this one, but hash map 

nn references/boyer_moore_majority_vote_algorithm
hl https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm
ln Boyer-Moore majority vote algorithm
co $ problems/169_majority_element
cr A way to solve in linear time with O(1) space

nn problems/67_add_binary
hl https://leetcode.com/problems/add-binary/description/
ln 67: Add Binary
co $ grind75
co $ paradigms/bit_manipulation

nn paradigms/bit_manipulation
ln Bit manipulation

nn problems/137_single_number_2
hl https://leetcode.com/problems/single-number-ii
ln 137: Single number 2
co $ paradigms/bit_manipulation
td work on LC 137

nn problems/260_single_number_3
hl https://leetcode.com/problems/single-number-iii
ln 260: single number 3
co $ paradigms/bit_manipulation
td work on LC 421

nn problems/187_repeated_DNA_sequences
ln 187: repeated DNA sequences
hl https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array
co $ paradigms/bit_manipulation
td work on LC 187

nn problems/318_max_product_word_lengths
hl https://leetcode.com/problems/maximum-product-of-word-lengths
ln 318: Maximum product of word lengths
co $ paradigms/bit_manipulation
td work on LC 318

nn problems/543_diameter_of_binary_tree
hl https://leetcode.com/problems/diameter-of-binary-tree
ln 543: Diameter of Binary Tree
co $ data_structures/binary_tree
co $ data_structures/binary_tree/depth_first_traversal

nn data_structures/binary_tree/depth_first_traversal
ln Depth-First Traversal of binary tree

nn references/binary_tree/terminology
hl https://en.wikipedia.org/wiki/Tree_(abstract_data_type)#Terminology
ln Terminology

nn references/binary_tree/terminology/degree
ln Degree: for a given node, its number of children.
rm A leaf, by definition, has degree 0.
ff In a binary tree structure, what is a degree?
fb Degree refers to the number of children for any given node.
co $ problems/543_diameter_of_binary_tree
cr Article refers to a leaf as any node having 1 degree,
cr including the root node if it has 1 degree or less

nn problems/876_middle_of_linked_list
hl https://leetcode.com/problems/middle-of-the-linked-list
ln 876: Middle of Linked List
co $ grind75
co $ data_structures/linked_list
rm Fast/slow pointer
co $ references/floyds_algorithm
cr the fast/slow pointer trick made me think of floyd's algorithm

nn problems/104_max_depth_binary_tree
ln 104: maximum depth of binary tree
hl https://leetcode.com/problems/maximum-depth-of-binary-tree
co $ grind75
co $ data_structures/binary_tree

nn references/tail_call
hl https://en.wikipedia.org/wiki/Tail_call
ln tail call: subroutine performed as the final action
ln of a procedure
co $ problems/104_max_depth_binary_tree
cr an optimzed solution involves tail recursion and BFS,
cr where the tail call is the recursive function

nn problems/217_contains_duplicate
hl https://leetcode.com/problems/contains-duplicate/
ln 217: Contains duplicate
co $ data_structures/hash_table
cr python set structure

nn problems/1768_merge_strings_alternately
hl https://leetcode.com/problems/merge-strings-alternately
ln 1768: merge strings alternative
co $ leetcode75
co $ paradigms/array_string

nn problems/1071_GCD_of_strings
hl https://leetcode.com/problems/greatest-common-divisor-of-strings
ln 1071: greatest common divisor of strings
co $ leetcode75
co $ paradigms/array_string

nn paradigms/array_string
ln array/string manipulation

nn problems/1431_kids_with_greatest_number_of_candies
hl https://leetcode.com/problems/kids-with-the-greatest-number-of-candies
ln 1431: Kids with greatest number of candies
co $ paradigms/array_string
co $ leetcode75

nn problems/605_can_place_flowers
hl https://leetcode.com/problems/can-place-flowers
ln 605: Can place flowers
co $ leetcode75
co $ paradigms/array_string

nn problems/345_reverse_vowels_stringa
hl https://leetcode.com/problems/reverse-vowels-of-a-string
ln 345: reverse vowels of a string
co $ leetcode75
co $ paradigms/two_pointer

nn problems/151_reverse_words_in_a_string
hl https://leetcode.com/problems/reverse-words-in-a-string
ln 151: Reverse words in a string
co $ paradigms/array_string
co $ leetcode75

nn problems/334_increasing_triplet_subseq
hl https://leetcode.com/problems/increasing-triplet-subsequence
ln 334: Increasing triplet subsequence
co $ leetcode75

nn problems/443_string_compression
hl https://leetcode.com/problems/string-compression/description
ln 443: String Compression
co $ leetcode75
co $ paradigms/array_string

nn problems/282_move_zeros
hl https://leetcode.com/problems/move-zeroes
ln 282: move zeros
co $ leetcode75
co $ paradigms/two_pointer

nn problems/392_is_subsequence
hl https://leetcode.com/problems/is-subsequence
ln 392: is subsequence
co $ leetcode75
co $ paradigms/two_pointer

nn problems/1679_max_number_of_ksum_pairs
hl https://leetcode.com/problems/max-number-of-k-sum-pairs
ln 1679: Max number of ksum pairs
co $ paradigms/two_pointer
co $ leetcode75

nn problems/643_maximum_average_subarray
hl https://leetcode.com/problems/maximum-average-subarray-i
ln 643: maximum average subarray
co $ leetcode75
co $ paradigms/sliding_window
co references/prefix_sum $
cr editorial used a cumulative sum to solve this,
cr AKA prefix sum. It was a little strange.

nn paradigms/sliding_window
ln Sliding Window

nn problems/1456_max_vowels_in_substring
ln 1456 max vowels in a substring of given length
hl https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length
co $ leetcode75
co $ paradigms/sliding_window

nn problems/1004_max_consecutive_ones_iii
ln 1001 Max consecutive ones iii
hl https://leetcode.com/problems/max-consecutive-ones-iii
co $ paradigms/sliding_window

nn problems/1493_longest_subarray_ones_deleting_elem
hl https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element
ln 1493: Longest Subarray of Ones after deleting one element
co $ leetcode75
co $ paradigms/sliding_window

nn problems/1732_find_highest_altitude
hl https://leetcode.com/problems/find-the-highest-altitude
ln 1732: find highest altitude
co $ leetcode75
co $ paradigms/prefix_sum

nn problems/724_pivot_index
hl https://leetcode.com/problems/find-pivot-index
ln 724 Pivot Index
co $ leetcode75
co $ paradigms/prefix_sum

nn paradigms/prefix_sum
ln Prefix Sum

nn problems/2215_difference_two_arrays
hl https://leetcode.com/problems/find-the-difference-of-two-arrays
ln 2215: Find the difference of two arrays
co $ data_structures/set
co $ leetcode75

nn data_structures/set
ln Set

nn problems/1207_unique_number_of_occurrences
hl https://leetcode.com/problems/unique-number-of-occurrences
ln 1207: unique number of occurrences
co $ leetcode75
co $ data_structures/set
co $ data_structures/hash_table

nn problems/1657_close_strings
hl https://leetcode.com/problems/determine-if-two-strings-are-close
ln 1657: Determine if two strings are close
co $ leetcode75
co $ data_structures/hash_table

nn problems/2352_equal_row_column_pairs
hl https://leetcode.com/problems/equal-row-and-column-pairs
ln 2352: Equal row and column pairs
co $ data_structures/hash_table
co $ leetcode75

nn problems/2390_removing_stars_from_a_string
ln 2390: removing stars from a string
hl https://leetcode.com/problems/removing-stars-from-a-string
co $ leetcode75
co $ data_structures/stack

nn problems/735_asteroid_collision
ln 735: Asteroid Collision
hl https://leetcode.com/problems/asteroid-collision
co $ leetcode75
co $ data_structures/stack

nn problems/349_decode_string
hl https://leetcode.com/problems/decode-string
ln 394: Decode String
co $ leetcode75
co $ data_structures/stack

nn problems/933_number_of_recent_cals
hl https://leetcode.com/problems/number-of-recent-calls
ln 933: Number of recent calls
co $ leetcode75
co $ data_structures/queue

nn problems/649_dota2_senate
hl https://leetcode.com/problems/dota2-senate
ln 649: Dota2 Senate
co $ leetcode75
co $ data_structures/queue

nn problems/2095_delete_middle_node
ln 2095 Delete the middle of a node in linked list
co $ leetcode75
co $ data_structures/linked_list
hl https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list
co $ references/floyds_algorithm
cr fast/slow pointer as seen in floyd's algorithm used to find middle of list
co $ problems/141_linked_list_cycle
cr A simlar solution for this problem also uses fast/slow pointers

nn data_structures/linked_list/fast_slow_pointer
ln Fast/Slow Pointer: a common technique in linked lists
ln where two pointers are used to traverse through
ln linked list at two different speeds, one usually 2x
ln faster. This can be used for things like cycle detection,
co $ references/floyds_algorithm
cr Floyd's algorithm for cycle detection is the algorithm 
cr most often associated with fast/slow pointers.
co problems/2095_delete_middle_node $
co problems/141_linked_list_cycle $
cr One solution involves using floyds algorithm using fast/slow pointers

nn problems/328_odd_even_linked_list
ln 328: Odd/even linked list
hl https://leetcode.com/problems/odd-even-linked-list
co $ leetcode75
co $ data_structures/linked_list

nn problems/2130_max_twin_sum_linked_list
hl https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list
ln 2130: Maximum twin sum of a linked list
co $ leetcode75
co $ data_structures/linked_list
co $ data_structures/linked_list/fast_slow_pointer
cr one solution involved going to middle of list, then
cr reversing the second half

nn problems/206_reverse_linked_list
hl https://leetcode.com/problems/reverse-linked-list
ln 206: reverse linked list
co $ leetcode75
co $ data_structures/linked_list
co $ problems/2130_max_twin_sum_linked_list
cr One solution to 2130 involves reversing the second
cr half of a linked list

nn problems/872_leaf_similar_trees
hl https://leetcode.com/problems/leaf-similar-trees
ln 872 Leaf Simlar Trees
co $ data_structures/binary_tree
co $ leetcode75

nn problems/1448_count_good_nodes
hl https://leetcode.com/problems/count-good-nodes-in-binary-tree/
ln 1448: Count good nodes
co $ leetcode75
co $ data_structures/binary_tree
co $ paradigms/depth_first_search

nn problems/437_path_sum_iii
ln 432 path sum ii
hl https://leetcode.com/problems/path-sum-iii
co $ data_structures/binary_tree
co $ paradigms/prefix_sum
cr yes, the solution for 437 uses prefix sum
co $ leetcode75
co $ paradigms/depth_first_search

nn problems/560_subarray_sum_equals_k
hl https://leetcode.com/problems/subarray-sum-equals-k
ln 560 Subarray Sum Equals K
co $ problems/437_path_sum_iii
cr 560 helps to understand the solution in 437
co $ paradigms/prefix_sum
co $ data_structures/hash_table

nn problems/1372_longest_zigzag_path
ln 1372: Longset ZigZag path in binary tree
hl https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree
co $ data_structures/binary_tree
co $ paradigms/depth_first_search
co $ leetcode75

nn problems/1161_max_level_sum_binary_tree
hl https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree
ln 1161: Maximum level sum of a binary tree
co $ data_structures/binary_tree
co $ paradigms/breadth_first_search
co $ leetcode75

nn problems/700_binary_search_tree
hl https://leetcode.com/problems/search-in-a-binary-search-tree
ln 700 Binary Search Tree
co $ data_structures/binary_search_tree
co $ leetcode75

nn problems/450_delete_node_BST
hl https://leetcode.com/problems/delete-node-in-a-bst
ln 450: Delete a node in a BST
co $ leetcode75
co $ data_structures/binary_search_tree

nn references/binary_search_tree/deletion
hl https://en.wikipedia.org/wiki/Binary_search_tree#Deletion
ln Delete a node from a binary search tree
co problems/450_delete_node_BST $
cr This solution outlined seems different then the LC editorial
co $ data_structures/binary_search_tree

nn data_structures/binary_search_tree/successor
ln Successor: next node in inorder traversal. To find,
ln go right once, then as many times to the left as possible
co $ ..

nn data_structures/binary_search_tree/predecessor
ln Predecessor: previous node in inorder traversal, To find,
ln go left once, then as many times to the right as possibl
co $ ..

nn references/tree_rotation
hl https://en.wikipedia.org/wiki/Tree_rotation
ln Tree rotation: an operation on a binary tree that
ln changes the structure without interfering with the
ln order of the elements.
co $ problems/450_delete_node_BST
cr I initially approached this problem thinking I could
cr do a tree rotation, but this turns out to not be correct
ff What does a tree rotation do?
fb A tree rotation is an operation on a binary tree
fb that changes the structure without interfering with
fb the order of the elements
co $ data_structures/binary_tree

nn problems/841_keys_and_rooms
hl https://leetcode.com/problems/keys-and-rooms
ln 841 Keys and Rooms
co $ leetcode75
co $ data_structures/graph
co $ paradigms/depth_first_search

nn data_structures/graph
ln Graph

nn problems/547_number_of_provinces
hl https://leetcode.com/problems/number-of-provinces/
ln 547: number of provinces
co $ leetcode75
co $ data_structures/graph
co $ paradigms/depth_first_search

nn problems/1466_reorder_routes_to_city_zero
hl https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero
ln Reorder routes to make all paths lead to the city zero
co $ leetcode75
co $ data_structures/graph
co $ paradigms/depth_first_search

nn problems/399_evaluate_division
hl https://leetcode.com/problems/evaluate-division
ln 399: Evaluate division
co $ leetcode75
co $ data_structures/graph
co $ paradigms/depth_first_search

nn problems/1926_nearest_exit_from_entrance_in_maze
hl https://leetcode.com/problems/nearest-exit-from-entrance-in-maze
ln 1926: nearest exit from entrance in maze
co $ leetcode75
co $ data_structures/graph
co $ paradigms/breadth_first_search

nn problems/215_kth_largest_element
ln 215: kth largest element in an array
hl https://leetcode.com/problems/kth-largest-element-in-an-array
co $ data_structures/priority_queue
co $ leetcode75

nn data_structures/priority_queue
ln Priority Queue

nn problems/2336_smallest_number_in_infinite_set
ln 2336: smallest number in infinite set
hl https://leetcode.com/problems/smallest-number-in-infinite-set
co $ leetcode75
co $ data_structures/priority_queue

nn problems/2542_maximum_subsequence_score
hl https://leetcode.com/problems/maximum-subsequence-score
ln 2542: maximum subsequence score
co $ leetcode75
co $ data_structures/priority_queue

nn problems/2462_total_cost_hire_k_workers
hl https://leetcode.com/problems/total-cost-to-hire-k-workers
ln 2462: total cost to hire k workers
co $ data_structures/priority_queue
co $ leetcode75

nn problems/374_guess_number_lower_higher
hl https://leetcode.com/problems/guess-number-higher-or-lower
ln 374: Guess number lower or higher
co $ leetcode75
co $ paradigms/binary_search

nn problems/2300_successful_pairs_potions_spells
hl https://leetcode.com/problems/successful-pairs-of-spells-and-potions
ln 2300: successful pairs of potions and spells
co $ leetcode75
co $ paradigms/binary_search

nn problems/162_find_peak_element
hl https://leetcode.com/problems/find-peak-element/
ln 162: find peak element
co $ leetcode75
co $ paradigms/binary_search
