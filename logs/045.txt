@2024-07-03 Day 45.
37 days left of batch.

---

Prev:

Tiny Creature Sounds /
Told Told Some People About It /
Then I installed zig

---

Next:

|| @!(taskref "create-chatter-sounds")!@: Build
up some jitter constructs.

|| @!(taskref "add-demos-page")!@: Quickly made
a demos page with links.

|| @!(taskref "react-managing-state")!@: Most
likely will have time to do some reading on this.

|| @!(taskref "resume-setup")!@: Building the
metadata structure out more.

|| @!(taskref "dagzet-lists")!@: Implement ordered
lists in dagzet (needed for dagzet setup).


@07:59 Adding some words to landing page

@08:00 Morning triage.

@08:08 I want to build some jitter constructs today #create-chatter-sounds

The first will be a randi like module clocked with
an external phasor. The second will be a phasor
whose rate can be randomized every period. Together,
they can build a pretty decent jitter signal.

---

I'll probably be extracting my LCG logic into
an RNG module as well.

@08:10 Going to tackle this this morning #add-demos-page

@08:11 Ordered lists in dagzet needed for resume #resume-setup #dagzet-lists
I know, I know, I'm overengineering this.

@08:17 Kickstart: way to set up neovim with LSP? #investigate-kickstart-neovim

Dan mentioned using VSCode again, and I'm inclined to
take his advice. However, before I try that, I want
to see if I can get some decent LSP things working
with NeoVim. Would be especially helpful if I
can get it running on this Alpine thinkpad.
---
Found Kickstart while trying to google "typescript in
neovim". This was the other thing mentioned too:
[[https://github.com/pmizio/typescript-tools.nvim]].

@08:21 Getting ready to publish.

@08:36 Start implementing ordered lists in dagzet #dagzet-lists #timelog:00:45:56
As reference, there is my resume dagzet code which
has some prototype syntax.

@08:35 I really need to rewrite dagzet #dagzet-rust
My lua implementation was always designed to just
be a prototype, and nowadays it's getting quite heavy.
Now that I'm a bit more familiar with the language,
I don't think it'd be too difficult to build it in
Rust, tbh. I think the standard library has enough
rich data types that it should be pretty
straightforward.

@08:52 Now I need to think about table schema #dagzet-lists
I think I know what I want in the schema, but it comes
down to naming. Working out the words here.
---
A list belongs to a node, and has items in the list,
which are other nodes in the current namespace. Each
item has a position in the list, which is known.
I will want these positions to be zero-indexed.

@09:05 I am inconsistent with design philosophy here #dagzet-lists
This approach I'm using for representing lists is
more SQL-y compared to say, how I'm handling =dz_lines=.
I'm using more rows: each list item gets a row with
a position. In theory, I should be able to
reconstruct the list using some join and amalgamation
operation in vanilla SQL.
---
By comparison, the other parts of this code represent
lists as JSON arrays encoded as strings. SQLite does
come with JSON bindings now by default, so it seems
this is reasonably portable. But it does require
that extra JSON parser, and a part of me wonders
if that was the right decision.
---
So, consider this an experiement. I'll have both:
more SQL-driven and more JSON-driven,
and I'll see which one feels better over time.

@09:10 Making SQL query to reproduce the list #dagzet-lists
Nice! There was a double join on the same table
I had to do and I pretty much just guessed it.
---
The query I made:

===
#+BEGIN_SRC sqlite
SELECT dz_nodes.name, group_concat(itemlist.name) FROM dz_lists
INNER JOIN dz_nodes on dz_nodes.id == dz_lists.node,
dz_nodes as itemlist on itemlist.id == dz_lists.item
GROUP BY dz_nodes.name
ORDER BY dz_lists.position;
#+END_SRC
===

@09:35 Off to make a simple RNG module #create-chatter-sounds #timelog:00:07:07

@09:41 Implementing randi #create-chatter-sounds #timelog:00:17:31

@09:59 Testing random line on chatter example #create-chatter-sounds #timelog:00:08:54

@10:09 Working out jitter line #create-chatter-sounds
An ideal jitter line would be a random line segment
clocked a phasor that some kind of variable fluctuation
in timing. But how does that phasor's rate get controlled?
---
The best answer I can come up with is to have a specialized
phasor whose rate can be smoothly randomized within
a range. This, combined with the random line generator
made previously, would build up the components for
a jitter line generator.
---
As a test, this random phasor could be used on the
chatter test to modulate how quickly the shapes are
changing.

@10:18 Building out random phasor #create-chatter-sounds #timelog:00:21:22
Yes, I think I'm going to call it RandomPhasor.
I'm going to copy and paste the phasor code for now,
since there's not a lot of code. It just doesn't
seem worth it to DRY it right now.

@10:53 Implementing Jitter, then that's enough of this for the day #create-chatter-sounds #timelog:00:19:03
This completes the idea I was thinking about

@11:50 Got roped into conversation, but clock is resumed #create-chatter-sounds

@15:31 had lunch, lots of conversations, now on floor 5.

@15:32 back to adding structure to resume. #resume-setup #timelog:00:40:44

@15:50 I need to think about how I'm going to template this. #resume-setup
As a sidetrack, try to see how hard text templates

@16:16 This was a very unproductive 40 minutes. #resume-setup
I tried exploring go templates briefly. I don't think
this is really going to help me. The data format
is what is most important. I think I'm just going
whip something up in janet, shell, or lua.
