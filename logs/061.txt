@2024-07-19 Day 61.
21 days left of batch.
---
Prev:

Negation in NAND /
is a requirement for /
Turing completeness

---

Next:

|| @!(taskref "dagzet-rust")!@: connection remarks,
and plan next steps. cycle checking? sqlite code
generation?

|| @!(taskref "demo-trio")!@: get the event-driven
gesture working

|| @!(taskref "gesture-reset")!@: implement gesture
reset that happens on phase reset.

@07:48 Morning triage

@08:12 Connection remarks next, then what? #dagzet-rust
My goal is to use this rust port as a drop-in
replacement for my current dagzet program.
So, a good thing to do would be to write a program
that scrapes all the current commands used in
my RC dagzet instance.
---
I also have more than enough here to begin
working on implementing topological sort
and SQLite code generation.

@08:19 Clock resets are going to throw off gesture algorithm #demo-trio
One of the things I am doing in Trio is forcing
a phase reset on pen down so the voices always
stagger the same way. The funderlying rephasor in
the gesture signal generator does not have a way
of handling phase resets, so it'll assume a faster
tempo change and cause unwanted jumps in time.
The rephasor needs a way to be told that there
has been a phase reset, which would cause it to
skip calculating the delta time in the next
sample tick.
---
I wonder if we can build a test around this?

@08:26 Task created for gesture reset #gesture-reset #demo-trio
I want to not only do the fix, but create a test
in the test suite that showcases the problem before
the fix is created, just so I know that I properly
understand the problem that I am trying to solve.

@08:29 Publishing

@09:04 Connection remarks in dagzet #dagzet-rust #timelog:01:02:06

@09:06 Connection remarks notes: more difficult than expected #dagzet-rust
This is more difficult than I expected. A connection remark
needs to reference a connection (the last connection made).
So, how does one reasonably accomplish this?
---
Since the connections are a pair,
one approach is to use a 2-dimensional hashmap of values.
It feels like a lot more space is used up here. It also
duplicates some of the logic in the connections hashmap.
---
Another thing to do is to somehow reference the connection.
An actual Rust memory reference could cause the borrow
checker to be grumpy. Using unique ID values to reference
each connection, and having that be a key in a hash table
could work. This could become a bookkeeping problem if
I ever added the ability to remove connections, but there
are no plans to add such a feature.
---
Connection ID can be their position in the "connections"
vector.
---
Since there is no way to selecting a specific connection,
it is reasonable to assume that the last connection
will always be implicitely be what remarks are being
written to. So, the ID will always be length of the vector
(minus one for the index).

@09:23 Making tests for connection remarks #dagzet-rust

@09:33 Implementing connection remarks #dagzet-rust

@09:59 I am weirdly stumped as to why this test is failing #dagzet-rust
It was silently erroring. I needed to add a namespace.


@10:16 Time for unknown nodes. #dagzet-rust #timelog:00:21:57

@10:20 before topsort, but unknown nodes #dagzet-rust
I initially thought I was ready for topsort and cycle
checking. But unknown node resolution should happen
first.
---
An edge list should be created from the connections for
the topsort. But those should all be resolved ID values.
"Check unknown" nodes should return a set of nodes
that do not exist in the node.
---
Rust does have a set in their library! Huzzah! Called
HashSet. That's what I need.

@10:26 Building test for unknown node checker #dagzet-rust

@10:37 Implementing unknown nodes. #dagzet-rust

@10:39 Begin cycle checking #dagzet-rust #timelog:00:22:41

@10:42 How to make this a testable component? #dagzet-rust
The trick here is that the connections need to
be resolved, which is another step to test independently.
---
A connection list, after it has been verified, should be
turned into an edge list. This function is still allowed
to error out. This edge list then gets passed in to the
cycle checker.
---
Note: Topsort makes use of sets that will expand and grow.
I expect to dynamically generate these inside the function.
---
Generating an edgelist should come first. Panic on missing
nodes for now. that can be fixed later.
---
The top-level cycle checker should be a method called =check_for_cycles=.
The original implementation was able to get some information
on these cycles.
---
Looks like the original topsort populates a "loops found"
list. I will do the same, only it'll be a HashSet. On success
it will return an Ok, otherwise an error code.

@10:51 Implementing initial cycle checker test #dagzet-rust

@11:02 Placeholder tests and functions in place. #dagzet-rust
Implementation will come next. Signing off for now.
