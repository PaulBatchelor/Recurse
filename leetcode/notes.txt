8/12:334:try ou tmy solution
8/12:238:understand their solution better
8/12:443:pretty much the same, they used built-in str2num
8/12:283:Figured out suboptimal, optimal with swaps worth study
8/12:393:Almost got 2-pointer right. This editorial is ridiculous though, but covers more fancy algos
8/12:11:looked at this one before
8/12:1679:Struggled figuring it out 2 pointer, worth looking into more (many solutions)
8/13:643:Unintuitive solutions. prefix sum
8/13:1456:Better intuition for efficient sliding window needed
8/13:1004:Revist. Reference and attempt failed.
8/13:1493:Seems like 1004, wait on it
8/13:1732:Trivial
8/13:724:Trivial
9/19:121:Two-pointer solution. Implementation seems to work.
9/19:1:hashmap solution
9/19:238:Tricky. Ended up using 2 product sum tables together. I attempted this one before?
9/19:226:Used recursive DFS approach to invert binary tree.
9/19:3:It seems to work using a hashmap and linear sweep, though I am skeptical about correctness.
9/22:98:I believe I implemented the recursive approach for this one correctly.
9/22:1456:Sliding window solution implemented.
9/23:20:Feels like a pretty standard linear time solution, what's a clean way in python to handle tedious chain of conditions?
9/23:21:I still get confused about when to use logical OR vs AND. This linked list problem was fine other than that
9/25:125:solved using built-in python3 preprocessing, and also two-pointer
9/25:242:solved using hashmap comparisons, as well as sorting and comparing strings
9/25:704:It took me a while to coordinate the binary search incantation correctly
9/25:733:Went with recursive flood fill solution. Hardest part was making sure my test scaffolding was correct.
9/25:53:I knew the solution involved sliding window and 2-pointer, but it took me a while to get it right.
9/25:57:The problem intimidated me, but I think I came up with a decent enough 2-step approach.
9/26:542:Treated this as a BFS problem with a double queue.
9/26:973:Solved it using a mix of a hashmap and a max-heap. The main approach was simpler, used less data structures and had similar time complexity (though distance was computed more times).
9/27:3:Revisted. My initial solution was broken, fixed it. Looked up editorial and implemented the other solutions.
9/30:102:Typical BFS binary tree problem, with some extra details out the return output
9/30:133:BFS graph traversal problem. I wrote some scaffolding to test some of it out. It looks mostly correct?
9/30:150:Couldn't resist doing this one. I love RPN.
10/1:207:Knew it was a DFS directed graph problem, took me a while to get details right. Still not sure if it's correct.
10/1:208:Most of the time was debugging my incorrect test inputs.
10/1:322:NOT DONE. I think I remember hearing that this was a dynamic programming problem?
10/2:322:Got something mostly working the brute-force recursive way. This is good enough.
10/2:238:Revisiting. WIP constant space solution involving using repeated subtraction. Lots of edge cases to address still.
10/2:1184:Done in mock interview with DF. Managed a linear time solution, then optimized it slightly by conoslidating loops and breaking early.
10/3:155:I had to look up how to do this. Once I knew the "trick", it was trivial to implement. Terrible.
10/3:98:I did this one again in the LC browser. I didn't check root for None, so now I'm not sure how well the validatoionline works.
10/3:200:I don't love my solution because I am keeping track of visited nodes. I wanted something more elegant.
10/4:994:I tried this problem before on paper. This was the first time coding it up. It took me a while to think up the solution.
10/4:33:Another one I did before on paper. Did this one untimed. Binary search with a twist.
10/5:39:UNFINISHED. I got stuck. Can't figure out the backtracking logic correctly.
10/5:46:Permutations. Had to nap on this one before coming up with this subpar recursive solution with lots of copying.
10/5:39:FINISHED. I turned this into a priority queue problem. Damn.
10/6:56:Learned I have to submit to subject it to all the tests. I don't love my solution, but it took it. I think it wanted something more clever.
10/6:981:My first approach was correct but too slow for submission. They wanted a O(log(n)) lookup time, which was tricky to implement correctly
10/6:236:Solved, but slow. Took me a long time to get this answer, a bit clunky kind of DFS with explicit stack
10/10:733:Solved using queue. Whitespace sensitivity took up time.
10/11:226:My second attempt was a little less elegant than my previous attempt, but same recursive approach.
10/11:721:UNFINISHED. Really thought this was just simple set manipulation, but there's an edge case where users become split
10/14:206:Completed again the linear way.
10/14:721:Feels messy, but it works, technic
10/14:72:I gave a workable but brute-force answer. Did not do the follow-up which would make it harder.
10/20:416:Dynamic programming problem, knapsack-aligned. I just looked up the answer on wikipedia (and the code was still slightly incorrect as well!)
10/21:70:Turned it into a dynamic programming problem with memoization.
10/21:409:A hashmap problem. Edge case to process was how to handle the center (keep track of max odd, store halfcount)
10/21:54:Spiral. I came up with a procedural solution that was tedious to code, but quite performant. Maybe it would have been easier to think of it as a constrained graph traversal problem?
10/22:1011:Binary Search. Did not follow the hint exactly (use boolean function), which cost me time. Working out the tester was key.
10/24:78:Combinatorial problem. Size was small enough to solve it using recursion.
10/24:199:Double queue. Recalled this solution from a few months ago.
10/24:5:After a few attempts at elegance, I went with a brute force solution
10/25:8:atoi. used a lot of python mechanims for trivial stuff like lstrip() and isnumeric(). got caught up in the many edgecases. trivial, but still tricky.
10/25:62:started with graph traversal, then memory issues pushed me to dynamic programming. I apparently did this already in august? probably looked it up. I figured it out after looking up pascals triangle from TADM.
10/28:105:Binary tree construction. This one took me many many hours over a few days, and required reviewing preorder and inorder traversals, but I figured it out by myself.
10/28:11:Did this one in under 4 minutes. I think I know this one pretty well.
11/1:17:Managed to do this one again in about 25min, not sure I like how I did it.
11/3:79:I struggled figuring out the right pattern to apply for this. I eventually settled on an okay recursive DFS solution.
11/3:438:Sliding window using Counter. LC tells me it's slow, probably cuz I'm doing a comparison each time. This could probably be improved. Also smells like a memoization/dynamic programming problem too.
11/10:621:Managed to get something working only after looking at hints.
