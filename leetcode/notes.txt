8/12:334:try ou tmy solution
8/12:238:understand their solution better
8/12:443:pretty much the same, they used built-in str2num
8/12:283:Figured out suboptimal, optimal with swaps worth study
8/12:393:Almost got 2-pointer right. This editorial is ridiculous though, but covers more fancy algos
8/12:11:looked at this one before
8/12:1679:Struggled figuring it out 2 pointer, worth looking into more (many solutions)
8/13:643:Unintuitive solutions. prefix sum
8/13:1456:Better intuition for efficient sliding window needed
8/13:1004:Revist. Reference and attempt failed.
8/13:1493:Seems like 1004, wait on it
8/13:1732:Trivial
8/13:724:Trivial
9/19:121:Two-pointer solution. Implementation seems to work.
9/19:1:hashmap solution
9/19:238:Tricky. Ended up using 2 product sum tables together. I attempted this one before?
9/19:226:Used recursive DFS approach to invert binary tree.
9/19:3:It seems to work using a hashmap and linear sweep, though I am skeptical about correctness.
9/22:98:I believe I implemented the recursive approach for this one correctly.
9/22:1456:Sliding window solution implemented.
9/23:20:Feels like a pretty standard linear time solution, what's a clean way in python to handle tedious chain of conditions?
9/23:21:I still get confused about when to use logical OR vs AND. This linked list problem was fine other than that
9/25:125:solved using built-in python3 preprocessing, and also two-pointer
9/25:242:solved using hashmap comparisons, as well as sorting and comparing strings
9/25:704:It took me a while to coordinate the binary search incantation correctly
9/25:733:Went with recursive flood fill solution. Hardest part was making sure my test scaffolding was correct.
9/25:53:I knew the solution involved sliding window and 2-pointer, but it took me a while to get it right.
9/25:57:The problem intimidated me, but I think I came up with a decent enough 2-step approach.
9/26:542:Treated this as a BFS problem with a double queue.
9/26:973:Solved it using a mix of a hashmap and a max-heap. The main approach was simpler, used less data structures and had similar time complexity (though distance was computed more times).
9/27:3:Revisted. My initial solution was broken, fixed it. Looked up editorial and implemented the other solutions.
9/30:102:Typical BFS binary tree problem, with some extra details out the return output
9/30:133:BFS graph traversal problem. I wrote some scaffolding to test some of it out. It looks mostly correct?
9/30:150:Couldn't resist doing this one. I love RPN.
10/1:207:Knew it was a DFS directed graph problem, took me a while to get details right. Still not sure if it's correct.
10/1:208:Most of the time was debugging my incorrect test inputs.
10/1:322:NOT DONE. I think I remember hearing that this was a dynamic programming problem?
10/2:322:Got something mostly working the brute-force recursive way. This is good enough.
10/2:238:Revisiting. WIP constant space solution involving using repeated subtraction. Lots of edge cases to address still.
10/2:1184:Done in mock interview with DF. Managed a linear time solution, then optimized it slightly by conoslidating loops and breaking early.
10/3:155:I had to look up how to do this. Once I knew the "trick", it was trivial to implement. Terrible.
10/3:98:I did this one again in the LC browser. I didn't check root for None, so now I'm not sure how well the validatoionline works.
10/3:200:I don't love my solution because I am keeping track of visited nodes. I wanted something more elegant.
10/4:994:I tried this problem before on paper. This was the first time coding it up. It took me a while to think up the solution.
10/4:33:Another one I did before on paper. Did this one untimed. Binary search with a twist.
10/5:39:UNFINISHED. I got stuck. Can't figure out the backtracking logic correctly.
10/5:46:Permutations. Had to nap on this one before coming up with this subpar recursive solution with lots of copying.
10/5:39:FINISHED. I turned this into a priority queue problem. Damn.
10/6:56:Learned I have to submit to subject it to all the tests. I don't love my solution, but it took it. I think it wanted something more clever.
10/6:981:My first approach was correct but too slow for submission. They wanted a O(log(n)) lookup time, which was tricky to implement correctly
