8/12:334:try out my solution
8/12:238:understand their solution better
8/12:443:pretty much the same, they used built-in str2num
8/12:283:Figured out suboptimal, optimal with swaps worth study
8/12:393:Almost got 2-pointer right. This editorial is ridiculous though, but covers more fancy algos
8/12:11:looked at this one before
8/12:1679:Struggled figuring it out 2 pointer, worth looking into more (many solutions)
8/13:643:Unintuitive solutions. prefix sum
8/13:1456:Better intuition for efficient sliding window needed
8/13:1004:Revist. Reference and attempt failed.
8/13:1493:Seems like 1004, wait on it
8/13:1732:Trivial
8/13:724:Trivial
8/13:2215:Got it
8/13:1207:Got it. Alt solution was weird (counting sort)
8/14:1657:Grokked. Alt solutions are sily. DS optmiziation. I don't care.
8/14:2352: used a set instead of histmap. edit: also has trie solution
8/14:735:Implemented in python. I know this pretty well.
8/14:394:braindead too tired to figure out
8/14:933:Got the logic right. learned about deque in python (did not impl tho)
8/14:649:I misunderstood the problem. it looks more involved. revisit.
8/15:2095:mostly got simple approach, but missed a few details. fast/slow I mostly guessed correctly.
8/15:2130:Bonkers solution of mine was incomplete, more complex than approaches used
8/16:104:mainly grokked recursive approach, other solutions prevented stack overflow
8/16:1448:want to take another pass before checking. feels close.
8/18:437:Grokked the idea of it. Could probably stand to look at smaller subproblems.
8/19:1372:Nailed it.
8/19:236:My answer is suboptimal. Probably correct. Editorial misread the the problem and is incorrect.
8/19:199:Initially approached like DFS, incorrectly. Editorial has good BFS recap.
8/19:1161:Kinda half-assed this based on two-queue approach in 199. I liked the given solution.
8/19:700:Nailed it.
8/21:450:I think my DFS with swap could have worked, the canonical approach in editorial using BST/pred/succ better
8/21:841:Got the recursive solution correct, stack would have been more elegant/better
8/22:547:I think I got this one right using BFS approach
8/22:1466:I do not understand solution fully. Revsit.
8/23:399:Hard problem. Figured out the crux of the DFS pathfinding problem, but missed important details (using product of division accum instead of union-find, LC-952)
8/23:1926:I thinik my approach works? I used double queue isntead of single queue. cleaner than editorial.
8/23:994:Lazy. ONly worked ou tgist. probably deserves more thought.
8/26:215:Almost figurd out. Working impl but forgot to zddress edge case.
8/25:2336:missed most of small details. problem is harder than it looks.
8/26:2542:revist. I exhausted myself with this one.
8/27:2542:revisted. This was very tricky, even with the answers in front of me.
8/27:374:Mostly right I think. I will double check.
9/19:121:Two-pointer solution. Implementation seems to work.
9/19:1:hashmap solution
9/19:238:Tricky. Ended up using 2 product sum tables together. I attempted this one before?
9/19:226:Used recursive DFS approach to invert binary tree.
9/19:3:It seems to work using a hashmap and linear sweep, though I am skeptical about correctness.
9/22:98:I believe I implemented the recursive approach for this one correctly.
9/22:1456:Sliding window solution implemented.
9/23:20:Feels like a pretty standard linear time solution, what's a clean way in python to handle tedious chain of conditions?
9/23:21:I still get confused about when to use logical OR vs AND. This linked list problem was fine other than that
9/25:125:solved using built-in python3 preprocessing, and also two-pointer
9/25:242:solved using hashmap comparisons, as well as sorting and comparing strings
9/25:704:It took me a while to coordinate the binary search incantation correctly
9/25:733:Went with recursive flood fill solution. Hardest part was making sure my test scaffolding was correct.
9/25:53:I knew the solution involved sliding window and 2-pointer, but it took me a while to get it right.
9/25:57:The problem intimidated me, but I think I came up with a decent enough 2-step approach.
9/26:542:Treated this as a BFS problem with a double queue.
9/26:973:Solved it using a mix of a hashmap and a max-heap. The main approach was simpler, used less data structures and had similar time complexity (though distance was computed more times).
9/27:3:Revisted. My initial solution was broken, fixed it. Looked up editorial and implemented the other solutions.
9/30:102:Typical BFS binary tree problem, with some extra details out the return output
9/30:133:BFS graph traversal problem. I wrote some scaffolding to test some of it out. It looks mostly correct?
9/30:150:Couldn't resist doing this one. I love RPN.
10/1:207:Knew it was a DFS directed graph problem, took me a while to get details right. Still not sure if it's correct.
10/1:208:Most of the time was debugging my incorrect test inputs.
10/1:322:NOT DONE. I think I remember hearing that this was a dynamic programming problem?
10/2:322:Got something mostly working the brute-force recursive way. This is good enough.
10/2:238:Revisiting. WIP constant space solution involving using repeated subtraction. Lots of edge cases to address still.
10/2:1184:Done in mock interview with DF. Managed a linear time solution, then optimized it slightly by conoslidating loops and breaking early.
10/3:155:I had to look up how to do this. Once I knew the "trick", it was trivial to implement. Terrible.
10/3:98:I did this one again in the LC browser. I didn't check root for None, so now I'm not sure how well the validatoionline works.
10/3:200:I don't love my solution because I am keeping track of visited nodes. I wanted something more elegant.
10/4:994:I tried this problem before on paper. This was the first time coding it up. It took me a while to think up the solution.
10/4:33:Another one I did before on paper. Did this one untimed. Binary search with a twist.
10/5:39:UNFINISHED. I got stuck. Can't figure out the backtracking logic correctly.
10/5:46:Permutations. Had to nap on this one before coming up with this subpar recursive solution with lots of copying.
10/5:39:FINISHED. I turned this into a priority queue problem. Damn.
10/6:56:Learned I have to submit to subject it to all the tests. I don't love my solution, but it took it. I think it wanted something more clever.
10/6:981:My first approach was correct but too slow for submission. They wanted a O(log(n)) lookup time, which was tricky to implement correctly
10/6:236:Solved, but slow. Took me a long time to get this answer, a bit clunky kind of DFS with explicit stack
10/10:733:Solved using queue. Whitespace sensitivity took up time.
10/11:226:My second attempt was a little less elegant than my previous attempt, but same recursive approach.
10/11:721:UNFINISHED. Really thought this was just simple set manipulation, but there's an edge case where users become split
10/14:206:Completed again the linear way.
10/14:721:Feels messy, but it works, technic
10/14:72:I gave a workable but brute-force answer. Did not do the follow-up which would make it harder.
10/20:416:Dynamic programming problem, knapsack-aligned. I just looked up the answer on wikipedia (and the code was still slightly incorrect as well!)
10/21:70:Turned it into a dynamic programming problem with memoization.
10/21:409:A hashmap problem. Edge case to process was how to handle the center (keep track of max odd, store halfcount)
10/21:54:Spiral. I came up with a procedural solution that was tedious to code, but quite performant. Maybe it would have been easier to think of it as a constrained graph traversal problem?
10/22:1011:Binary Search. Did not follow the hint exactly (use boolean function), which cost me time. Working out the tester was key.
10/24:78:Combinatorial problem. Size was small enough to solve it using recursion.
10/24:199:Double queue. Recalled this solution from a few months ago.
10/24:5:After a few attempts at elegance, I went with a brute force solution
10/25:8:atoi. used a lot of python mechanims for trivial stuff like lstrip() and isnumeric(). got caught up in the many edgecases. trivial, but still tricky.
10/25:62:started with graph traversal, then memory issues pushed me to dynamic programming. I apparently did this already in august? probably looked it up. I figured it out after looking up pascals triangle from TADM.
10/28:105:Binary tree construction. This one took me many many hours over a few days, and required reviewing preorder and inorder traversals, but I figured it out by myself.
10/28:11:Did this one in under 4 minutes. I think I know this one pretty well.
11/1:17:Managed to do this one again in about 25min, not sure I like how I did it.
11/3:79:I struggled figuring out the right pattern to apply for this. I eventually settled on an okay recursive DFS solution.
11/3:438:Sliding window using Counter. LC tells me it's slow, probably cuz I'm doing a comparison each time. This could probably be improved. Also smells like a memoization/dynamic programming problem too.
11/6:310:Got it working the slow way, but the answer they wanted was extremely clever (topological sort)
11/10:621:Managed to get something working only after looking at hints.
11/11:739:Brute force was too slow, spent hours trying to get priority queues to fit the problem, but it was a monotonically increasing stack problem (which I had to learn about)
11/12:198:Attempted this before, but not without tests. My old version failed, this new one did okay with memoization.
11/12:134:Only managed to get brute force, but got TLE.
11/13:134:Greedy algorithm. Found solution on youtube via neetcode.
11/13:36:"Valid" doesn't mean "solveable". "Sudoku" is a misnomer.
11/13:49:Got this one pretty quickly. Hashtable. Sort keys.
11/13:152:Brute-forced it (TLE), then tried two-pointer (nope), then looked up answer (dynamic programming)
11/14:211:WIP. My Trie problem isn't working on a huge edge case. It's the correct data structure according to the solution, but my implementation is wrong.
11/15:211:Finished. My Trie wasn't actually a Trie because it wasn't actually a tree structure. Even with the answer, this took me a while to get right.
11/16:417:My dynamic programming solution was the wrong approach. Looked up the answer for BFS. Hello LeetCode Premium.
11/16:19:Managed to remember how linked lists worked all by myself
11/16:1730:BFS, similar to the pacific/atlantic water flow one (417).
11/16:287:Brute force was trivial. O(n) with constant space I needed to look up. See: floyd's algorithm. Small, but clever.
11/17:334:I don't think I understood this problem before. Solution probably wouldn't have been something I'd have known how to do then.
11/17:692:Lexicographic ordering threw me off. Python structures for this (Counter, Heap) seem to handle this for you implicitely.
11/17:347:Basically 692, same pattern. Editorial had slick python solutions using built-in heap method nlargest()
11/17:53:Kadane's algorithm. Attempted before (without checking) using two-pointer, then sliding window. It was wrong. Funnily enough, I reached for those again when I attempted this.
11/17:57:My solution passes, but is a little ugly because I kept coding up safeguards against edge cases. I am going to want to revisit.
11/18:542:BFS problem on a grid. pretty standard pattern.
11/18:973:I know more python now, so my heap-based solution was better
11/18:3:Repeated. Looks like I remembered the solution from before.
11/18:15:I did only the bruteforce version of this. I had to look up the answer (variation of 2sum)
11/19:102:Did this before, but probably untested. BFS binary tree, but misread how they wanted the results outputted (I initially thought pairs, but they wanted to group things by level). The simple test cases could be misinterpretted. Minor thing, but it looks like my previous attempt did the same thing.
11/19:122:Came up with BFS 2-step solution where neighbors were updated after all nodes were allocated. Editorial had a more slick BFS solution.
11/19:150:Subtle things related to divide-to-zero truncation. I used an actual stack, I was not clever enough to think of the in-place solution.
11/20:207:Solved it okay without because I know these problems with audio work, but processing the input correctly was tricky for me. It felt flipped? Ended up rewriting the editorial answer with domain-specific language instead of the generic graph terms.
11/20:208:Did this before. This Trie code was mostly just muscle memory.
11/21:322:I had a fuzzy notion of how to solve this (which was correct intuition), but ultimately had to look up the solution and see the implementation
11/21:238:Familiar already, so I had to recall what I did to come up with the answer. Reminds me of a prefix sum problem. Optimized version turned out to be the same solution, but "clever".
11/21:155:One of those confusing puzzles that is forever tedious when you know the answer. The slightly space-optimized version using min-tracker was new to me and mildly interesting.
11/22:89:I had a hunch about using ranges recursively, but I couldn't quite articulate it as code. The in-order traversal solution felt more intuitive once I looked it up.
11/22:200:I identified it as a BFS problem, couldn't get the code quite right, even to get all the base test cases to pass.
11/22:994:Got tripped up with the BFS because I forgot oranges would rot things simultaneously, but managed to fix this without help
11/23:33:Fought this one for many hours before giving up. As per usual, I was less close than I thought. Also, I think my left/right dyslexia made this difficult. Binary search isn't sticking for me. I feel like I keep missing details.
11/23:39:Managed to get this one reasonably quickly. The editorial used a "remaining" variable which was a little bit more clever than my "exceeds bounds" logic
11/23:1:Pretty straight forward.
11/23:20:Knew the pattern and got it mostly correct on the first attempt, but I forgot the edge case with too many open parens
11/23:21:Did it, but I definitely could have refined it. Ended up looking at the editorial, then claude for some really gross code golfing.
11/23:121:Accomplished with very little fuss. It made sense intuitively, but I wish I could explain how it works better.
11/24:125:Solution was quite fast to come up with, spent a good deal of time studying the python code instead
11/24:242:Python one-liner using Counter==Counter.
11/24:704:We've done a lot of binary search already.
11/24:235:Didn't get this one, had to look up the answer. I don't grok BSTs well enough.
11/25:110:Came up with a solution after some quick trial and error.
11/25:148:Didn't think to use a Set. Forgot about Floyd's algorithm.
11/25:232:I had a very stupid solution which technically worked, and was in line with what you were supposed to do.
11/25:278:Did this one already. Helped that I reviewed binary search.
11/25:169:Hashmap was straight forward. Lots of weird answers to this problem in editorial. Boyer-moore is surprisingly simple.
